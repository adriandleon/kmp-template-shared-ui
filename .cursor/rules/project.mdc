# Compose Multiplatform Project Rules - Template

## Project Overview
This is a Compose Multiplatform (CMP) project template targeting iOS and Android with shared UI. The project uses modern Kotlin Multiplatform architecture with best practices for scalable mobile development.

## Project Structure
```
{ProjectName}/
├── composeApp/       # Main Compose Multiplatform app module
│   ├── src/
│   │   ├── commonMain/    # Shared code (UI, business logic, data)
│   │   ├── androidMain/   # Android-specific implementations
│   │   ├── iosMain/       # iOS-specific implementations
│   │   ├── commonTest/    # Shared unit tests
│   │   ├── androidUnitTest/ # Android unit tests
│   │   └── iosTest/       # iOS unit tests
│   └── build.gradle.kts
├── iosApp/          # iOS app wrapper (minimal Swift code)
├── build.gradle.kts  # Root project configuration
└── gradle/          # Gradle wrapper and version catalogs
```

## Core Technologies

### UI Framework
- **Compose Multiplatform**: Shared UI for Android and iOS
- **Material3**: Design system and UI components
- **Decompose**: Navigation and component lifecycle management

### Architecture
- **MVVM + MVI**: ViewModel pattern with MVIKotlin for state management
- **Clean Architecture**: Layered architecture (data, domain, presentation)
- **Dependency Injection**: Koin for dependency management

### Data & Storage
- **Remote Database**: Supabase for backend services
- **Local Database**: Room for local data persistence
- **Local Preferences**: DataStore Preferences for app settings
- **Networking**: Ktor client with platform-specific engines

### Development Tools
- **Code Formatting**: ktfmt (official Kotlin style guide)
- **Linting**: Detekt with Detekt Compose Rules
- **Build Configuration**: BuildKonfig for secrets and build properties
- **Logging**: Kermit for cross-platform logging

### Analytics & Features
- **Analytics**: Firebase Analytics and Crashlytics
- **Feature Flags**: ConfigCat and Firebase Remote Config

## Architecture Patterns

### 1. MVVM + MVI with MVIKotlin
- **Store Interface**: Define `State`, `Intent`, `Message`, and `Action`
- **Pattern Flow**: `Intent` → `Store` → `Message` → `State`
- **State Management**: Use sealed interfaces for type-safe state
- **ViewModel**: Bridge between UI and business logic

### 2. Decompose Navigation
- **Component Interface**: Create `*Component.kt` for UI components
- **Implementation**: `Default*Component.kt` classes
- **Lifecycle**: Use `ComponentContext` for lifecycle management
- **State Exposure**: Expose `Value<Model>` for reactive state

### 3. Clean Architecture Layers
```
presentation/     # UI layer (Compose + ViewModels)
├── component/    # Decompose components
├── mapper/       # UI state mappers
└── store/        # MVIKotlin stores

domain/          # Business logic layer
├── entity/       # Domain models
├── repository/   # Repository interfaces
└── usecase/      # Business use cases

data/            # Data layer
├── datasource/   # Data sources (Supabase, Room, DataStore)
├── mapper/       # Data mappers
└── repository/   # Repository implementations
```

## Development Guidelines

### Code Organization
- **Package Structure**: Organize by feature, not by layer
- **Naming Conventions**:
  - Entities: `*Entity.kt`
  - Repositories: `*Repository.kt`
  - Use Cases: `*UseCase.kt`
  - Components: `*Component.kt`
  - Stores: `*Store.kt`
  - Composables: `*Screen.kt`, `*Component.kt`

### Compose UI Development
- **Composable Functions**: Use PascalCase, descriptive names
- **State Management**: Use `remember`, `mutableStateOf`, `StateFlow`
- **State Hoisting**: Move state as high as possible in the tree
- **Unidirectional Data Flow**: Data flows down, events flow up
- **Material3**: Use Material3 components and theming
- **Preview Annotations**: Every composable MUST have `@Preview`
- **Testing**: Use `Modifier.testTag()` for UI testing

### Platform Abstraction
- **Expect/Actual**: Use for platform-specific implementations
- **Common Interfaces**: Define in `commonMain`
- **Platform Implementations**: Implement in `androidMain`/`iosMain`
- **Dependencies**: Use KMP-compatible libraries only

## Data Management

### Supabase Integration
- **Client**: Use PostgREST client for database operations
- **Authentication**: Handle auth with Supabase Auth
- **Real-time**: Use Supabase real-time subscriptions
- **Error Handling**: Implement proper error handling

### Room Database
- **Entities**: Define `@Entity` classes for local data
- **DAO**: Create Data Access Objects for database operations
- **Database**: Configure Room database with migrations
- **Queries**: Use `@Query` annotations for database queries

### DataStore Preferences
- **Preferences**: Use for app settings and user preferences
- **Type Safety**: Use typed preferences with DataStore
- **Migration**: Handle preference migration from SharedPreferences

### Ktor Networking
- **Client**: Configure with platform-specific engines (OkHttp/Darwin)
- **Serialization**: Use Kotlinx Serialization for JSON
- **Interceptors**: Add logging and error handling interceptors
- **SSL Pinning**: Implement certificate pinning for security

## Dependency Injection with Koin

### Module Definition
```kotlin
val appModule = module {
    // Repositories
    singleOf(::DefaultUserRepository) { bind<UserRepository>() }
    
    // Use Cases
    factoryOf(::GetUserUseCase)
    
    // Data Sources
    singleOf(::SupabaseDataSource)
    singleOf(::RoomDataSource)
    
    // Stores
    factoryOf(::UserStore)
}
```

### Component Integration
- **Koin Annotations**: Use `@KoinComponent` for dependency injection
- **Factory Dependencies**: Use `factoryOf(::Constructor)`
- **Singleton Dependencies**: Use `singleOf(::Constructor)`
- **Interface Binding**: Use `bind<Interface>()`

## Feature Flags & Analytics

### ConfigCat Integration
- **Feature Flags**: Use `FeatureView` wrapper for conditional rendering
- **Remote Config**: Sync with Firebase Remote Config
- **A/B Testing**: Implement feature flag-based experiments

### Firebase Analytics
- **Events**: Track user actions and app events
- **Crashlytics**: Monitor crashes and errors
- **Performance**: Monitor app performance metrics

## Code Quality & Tools

### ktfmt Formatting
- **Style Guide**: Follow official Kotlin style guide
- **Gradle Plugin**: Configure ktfmt Gradle plugin
- **IDE Integration**: Use ktfmt in IDE for consistent formatting

### Detekt Linting
- **Rules**: Use Detekt with Compose rules
- **Configuration**: Customize rules in `detekt.yml`
- **CI Integration**: Run Detekt in CI/CD pipeline

### BuildKonfig
- **Secrets**: Store API keys and sensitive configuration
- **Environment**: Support debug/release variants
- **Type Safety**: Generate type-safe configuration classes

## Testing Strategy

### Unit Testing
- **Framework**: Use Kotest for testing
- **Mocking**: Use Mokkery for mocking dependencies
- **Coverage**: Aim for 90%+ test coverage
- **Test Organization**: Group tests by feature

### UI Testing
- **Compose Testing**: Use `ComposeTestRule` for UI tests
- **Test Tags**: Use `Modifier.testTag()` for element identification
- **Page Object**: Follow page object pattern for test organization

## Internationalization
- **Languages**: English (default), Spanish (es-r419), Portuguese (pt-rBR)
- **String Resources**: Extract all text to `strings.xml`
- **Content Description**: Provide accessibility descriptions
- **Preview Locales**: Test UI in all supported languages

## Performance Optimization
- **Compose Performance**: Use `remember`, `derivedStateOf`, `LazyColumn`
- **Memory Management**: Implement proper lifecycle management
- **Image Caching**: Use Coil for efficient image loading
- **Database Queries**: Optimize Room queries and use indices

## Security Best Practices
- **API Security**: Use HTTPS and certificate pinning
- **Data Encryption**: Encrypt sensitive data at rest
- **Authentication**: Implement secure authentication flows
- **Input Validation**: Sanitize user input to prevent attacks

## Build Configuration
- **Gradle**: Use Kotlin DSL and version catalogs
- **Multiplatform**: Configure Android and iOS targets
- **Dependencies**: Manage through `libs.versions.toml`
- **Signing**: Configure proper APK/AAB signing

## Customization for New Projects
1. **Package Names**: Replace `com.example.project` with your package
2. **Project Names**: Update app names and identifiers
3. **Configuration**: Update BuildKonfig and environment variables
4. **Documentation**: Update README and project documentation
5. **Dependencies**: Verify all dependencies are up to date

## Common Patterns
- **Repository Pattern**: Abstract data access
- **Use Case Pattern**: Encapsulate business logic
- **Observer Pattern**: Use StateFlow/SharedFlow for reactive streams
- **Factory Pattern**: Use for object creation
- **Builder Pattern**: Use for complex object construction